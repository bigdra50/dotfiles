# Claude Code スラッシュコマンド ベストプラクティス

## 概要

Claude Code のカスタムスラッシュコマンドを効果的に作成・管理するためのベストプラクティスガイドです。

## ファイル構成

### 配置場所
- **プロジェクト用**: `.claude/commands/`（チーム共有）
- **個人用**: `~/.claude/commands/`（個人専用）

### ファイル形式
- Markdown (`.md`) ファイル
- ファイル名がコマンド名になる
- 最初の見出しがコマンドの説明として使用される

## 基本設計原則

### 1. 明確な責務分離
各コマンドは単一の責務を持つべきです。

```markdown
# 良い例: 特定の機能に特化
/commit-staged - ステージされたファイルをコミット
/docs - ドキュメント生成

# 悪い例: 複数の責務が混在
/git-ops - Git操作全般（曖昧すぎる）
```

### 2. 予測可能なワークフロー
コマンドの実行順序と結果を予測できるようにします。

```markdown
# ワークフロー例
1. 現状分析
2. 前提条件の確認
3. メイン処理の実行
4. 結果の検証
5. エラーハンドリング
```

### 3. 包括的なエラーハンドリング
想定される失敗パターンを事前に定義します。

```markdown
## エラーハンドリング:
- 前提条件が満たされない場合
- ファイルが見つからない場合
- 権限エラーが発生した場合
- ネットワークエラーが発生した場合
```

## コマンド構造のパターン

### 基本パターン
```markdown
# コマンドタイトル

コマンドの目的と概要説明

## ワークフロー:
1. 具体的なステップ1
2. 具体的なステップ2
3. ...

## エラーハンドリング:
- エラーケース1
- エラーケース2

## 使用例:
`claude /command-name [arguments]`
```

### オーケストレーター パターン
複雑なタスクを段階的に実行する場合：

```markdown
# 複雑タスクの分解

## プロセス
1. **初期分析**
   - 全体スコープの理解
   - 依存関係の特定

2. **段階的計画**
   - 2-4個の連続ステップに分解
   - 各ステップ内で並列サブタスク実行

3. **段階別実行**
   - 現在ステップのサブタスク並列実行
   - 次ステップへの結果受け渡し

4. **適応的計画調整**
   - 各ステップ完了後の見直し
   - 残りステップの適切性検証
```

### ワークフロー固有パターン
Git操作、ドキュメント生成などの特定領域：

```markdown
# Git関連コマンドの例

## 前提条件確認:
- Gitリポジトリかどうか確認
- 未コミット変更の有無確認

## メイン処理:
- `git status` で現状把握
- 変更内容の分析
- 適切なコミットメッセージ生成

## 検証:
- コミット成功の確認
- 期待される状態になっているか確認
```

## 高度な機能

### フロントマター活用
```markdown
---
description: "詳細なコマンド説明"
allowed-tools: ["Bash", "Read", "Write"]
---

# コマンドタイトル
```

### 動的引数処理
```markdown
# 引数の活用

$ARGUMENTS が提供された場合の処理:
- 引数をコンテキストとして使用
- デフォルト動作をカスタマイズ
- 特定のファイルやディレクトリを対象化

使用例:
- `/docs src/` - srcディレクトリのドキュメント生成
- `/commit-chat 新機能追加` - 追加コンテキストでコミット
```

### Bash統合
```markdown
# システムコマンド統合

動的コンテキスト収集:
- `!git status` でリポジトリ状態取得
- `!find . -name "*.js"` でファイル一覧取得
- 結果をコマンド実行に活用
```

## 命名規則

### ファイル名
- 小文字使用
- ハイフン区切り（`-`）
- 動詞-名詞の組み合わせを推奨

```
# 良い例
commit-staged.md
docs-generate.md
branch-current.md

# 悪い例
CommitStaged.md
docs_generate.md
branchcurrent.md
```

### コマンド名
- 機能を明確に表現
- 統一した接頭辞を使用（チーム内で）

```
# 良い例
/commit-staged
/commit-chat
/branch-current

# 悪い例
/c
/stage-and-commit
/do-commit
```

## 実装のベストプラクティス

### 1. ユーザー確認の実装
重要な操作では必ずユーザー確認を行う：

```markdown
## ユーザー確認
5. 実行前の確認: "以下のファイルをステージングしてコミットしますか？"
6. ユーザーの明示的な同意を待つ (y/n)
7. 承認された場合のみ実行
```

### 2. 段階的出力
進捗を可視化する：

```markdown
## 実行フロー
1. 現在の状況を表示
2. 実行予定の操作を列挙
3. 各ステップの完了を報告
4. 最終結果をサマリー表示
```

### 3. 失敗時の復旧手順
```markdown
## 失敗時の対応
- 部分実行状態の検出
- ロールバック手順の提示
- ユーザーへの明確な次ステップ提示
```

## コマンド分類と責務

### プロジェクト管理系
- `prj-plan` - 作業計画管理
- `prj-dashboard` - プロジェクト状況表示
- `prj-update` - 進捗更新

### Git操作系
- `commit-staged` - ステージ済みファイルコミット
- `commit-chat` - 会話ベースコミット
- `branch-current` - ブランチ作成
- `fix-github-issue` - Issue対応

### ドキュメント系
- `docs` - ドキュメント生成
- `review` - レビュー資料作成

### 開発支援系
- `standup` - スタンドアップ準備
- `nippo-*` - 日報関連

## パフォーマンス考慮事項

### 1. 効率的な実行
- 並列実行可能な処理は同時実行
- 不要なファイル読み込みを避ける
- キャッシュ可能な情報は再利用

### 2. リソース管理
- 大きなファイルの部分読み込み
- メモリ使用量の最適化
- 長時間実行の分割

### 3. ユーザー体験
- 実行時間の目安提示
- 進捗状況の表示
- 中断可能な処理設計

## セキュリティ考慮事項

### 1. 入力検証
```markdown
## 引数検証
- ファイルパスの検証
- 危険なコマンドのフィルタリング
- 権限チェック
```

### 2. 機密情報保護
```markdown
## セキュリティ
- 機密情報のログ出力回避
- 一時ファイルの適切な削除
- 権限の最小化
```

## テスト戦略

### 1. 手動テスト
- 正常系の動作確認
- エラーケースの動作確認
- ユーザーインタラクションの確認

### 2. ドライラン機能
```markdown
## ドライラン対応
- 実際の変更を行わずに処理をシミュレート
- 実行予定の操作を表示
- ユーザーが結果を事前確認可能
```

## 継続的改善

### 1. 使用状況の監視
- よく使われるコマンドの特定
- エラー発生パターンの分析
- ユーザーフィードバックの収集

### 2. 定期的なメンテナンス
- 非推奨機能の削除
- 新しい要件への対応
- パフォーマンス改善

### 3. ドキュメントの更新
- 使用例の追加
- トラブルシューティング情報
- ベストプラクティスの共有

## チーム開発での運用

### 1. コマンド標準化
- 命名規則の統一
- 共通パターンの採用
- コードレビューの実施

### 2. 知識共有
- 有用なコマンドの共有
- 実装パターンの文書化
- 定期的な振り返り

### 3. バージョン管理
- コマンドの変更履歴管理
- 後方互換性の維持
- 段階的な移行計画

## まとめ

効果的なスラッシュコマンドは以下の特徴を持ちます：

1. **明確な責務** - 単一機能に特化
2. **予測可能性** - 実行結果が予想できる
3. **堅牢性** - エラーハンドリングが充実
4. **ユーザビリティ** - 使いやすく理解しやすい
5. **保守性** - 継続的改善が可能

これらの原則に従ってコマンドを設計することで、開発効率の向上とチームの生産性向上を実現できます。