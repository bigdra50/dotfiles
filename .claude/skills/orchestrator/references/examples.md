# 使用例

## 例1: 開発系タスク

```
タスク: 「テストを実行して、エラーがあれば修正してコミット」

=== Phase 0: タスク分類 ===
カテゴリ: 開発系
理由: 検証→修正→確定の明確なフロー

=== Phase 2: ステップ計画 ===
Step 1: 現状把握 [並列2タスク]
  - テスト実行
  - git status確認
Step 2: 問題修正 [依存: Step1結果による]
  - エラーがあれば修正
  - なければスキップ
Step 3: 確定 [単一タスク]
  - コミット作成
```

## 例2: 調査系タスク

```
タスク: 「このコードベースの認証フローを理解して説明して」

=== Phase 0: タスク分類 ===
カテゴリ: 調査系
理由: 探索的、正解が事前に不明

=== Phase 2: ステップ計画 ===
Step 1: 広範囲探索 [並列3タスク]
  - 認証関連ファイル検索
  - エントリーポイント特定
  - 設定ファイル確認
Step 2: 深掘り [Step1結果に依存]
  - 主要フローのトレース
Step 3: 統合 [単一タスク]
  - 説明文書作成
  チェックポイント: あり（理解が正しいか確認）
```

## 例3: 文書作成タスク

```
タスク: 「README.mdをレビューして改善提案を」

=== Phase 0: タスク分類 ===
カテゴリ: 文書作成
理由: 反復・推敲が必要

=== Phase 2: ステップ計画 ===
Step 1: 現状分析 [単一タスク]
  - README.md読み込みと構造分析
Step 2: 評価 [並列3タスク]
  - 内容の正確性チェック
  - 構成の妥当性チェック
  - 不足情報の特定
  チェックポイント: あり（改善方針確認）
Step 3: 改善案作成 [単一タスク]
  - 具体的な修正提案
```

## 例4: Boomerang適用版（Handoff活用）

```
タスク: 「認証フローにリフレッシュトークンを追加」

Step 1: Explore委譲
  → Handoff: "auth.ts, middleware.tsが主要ファイル"

Step 2: Plan委譲
  入力: Step 1のHandoff
  → Handoff: "TokenPair型追加、リフレッシュ検証ミドルウェア追加"

Step 3: default委譲
  入力: Step 2のHandoff
  → Artifacts: 3ファイル変更

Step 4: code-reviewer委譲
  入力: Step 3のArtifacts
  → Result: レビュー完了、問題なし

ポイント: 各ステップでHandoff情報のみ引き継ぎ、詳細は流入させない
```

## 例5: 競合分析（並列活用）

```
タスク: 「競合3社のAPI仕様を比較」

=== Phase 1: 初期分析 ===
タスク: 「競合3社のAPI仕様を比較」
カテゴリ: 調査系
スコープ: 3社のAPI仕様書を取得・比較・レポート作成
依存関係: 情報収集 → 比較軸抽出 → 比較表作成
必要リソース: WebFetch, Write

=== Phase 2: ステップ計画 ===
Step 1: 情報収集 [並列3タスク]
  - 1.1: A社API仕様取得
  - 1.2: B社API仕様取得
  - 1.3: C社API仕様取得
  入力: なし
  出力: 各社のAPI仕様（生データ）
  チェックポイント: なし

Step 2: 比較軸抽出 [単一タスク]
  - 2.1: 共通の比較軸を特定
  入力: Step 1の出力
  出力: 比較軸リスト
  チェックポイント: あり（軸の妥当性確認）

Step 3: 比較表作成 [単一タスク]
  - 3.1: 比較表とサマリ作成
  入力: Step 1, 2の出力
  出力: 最終レポート
  チェックポイント: なし
```
